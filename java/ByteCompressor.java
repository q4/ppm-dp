/* $Id$ */

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Random;
import java.util.Set;

/** Implements a generic Byte stream compressor.
  * <p>This class interfaces a given data model (such as PPM) to an
  * arithmetic coder, forming a compressor over byte sequences.
  * The data model should range over integers (0..256)
  * rather than bytes, to allow for the additional EOF symbol (256).
  * A static uniform base distribution over the permitted range of
  * integers is available as {@code ByteCompressor.base}.</p>
  * @see CharCompressor */
public class ByteCompressor {

  /** Lowest represented integer. */
  static final int bot = 0;  // alternative: -128
  /** Highest represented integer. */
  static final int top = 256; // alternative: +128

  /** EOF symbol. */
  static final int eof = top;

  /** Base distribution on byte values + EOF. */
  static final UniformInteger base = new UniformInteger(bot,top);

  /** Offset from unsigned byte to signed int. */
  //static final int offs = 128;

  /** Translates an ASCII character to an int value, using
    * this ByteCompressor's internal encoding. */
  public static int char2int(char c) {
    int b = (int) c;
    if (b >= bot && b <= top) {
      return (int) c;
    } else {
      throw new IllegalArgumentException("char "+c+" ("+b+") out of range");
    }
  }

  /** Translates a byte value to an int value,
    * using this ByteCompressor's internal encoding. */
  public static int byte2int(byte b) {
    return (int) b & 0xFF;
  }

  long encoded = 0;
  long decoded = 0;

  /** Data model with adaptive coding over integers. */
  AdaptiveCode<Integer> model = null;

  /** Constructs a new Byte stream compressor with given model. */
  public ByteCompressor(AdaptiveCode<Integer> model) {
    this.model = model;
  }

  /** Pretrains the model with a given training sequence. */
  public void train(Iterable<Byte> src) {
    for (Byte b : src) {
      model.learn((int) b & 0xFF);
    }
  }

  /** Compresses a byte sequence.
    * @param src source of input bytes
    * @param bw compressed bits are written here
    * @param ac arithmetic coder to be used for compression */
  public void compress(Iterable<Byte> src, BitWriter bw, Coder ac) throws IOException {
    ac.start_encode(bw);
    //DebugEncoder debug = new DebugEncoder(ac);
    for (Byte b : src) {
      model.encode((int) b & 0xFF, ac);
      model.learn((int) b & 0xFF);
      encoded++;
    }
    model.encode(eof, ac);
    ac.finish_encode();
    bw.close();
  }
  
  /** Decompresses a bitstream.
    * @param br source of compressed bits
    * @param os decoded bytes are written here
    * @param ad arithmetic coder to be used for decompression */
  public void decompress(BitReader br, OutputStream os, Coder ad) throws IOException {
    //Decoder debug = new DebugDecoder(ad);
    ad.start_decode(br);
    Integer x = model.decode(ad);
    while (x != eof) {
      os.write(x.byteValue());
      model.learn(x);
      decoded++;
      x = model.decode(ad);
    }
    ad.finish_decode();
    os.close();
  }
  
  /** Generates a byte sequence from the data model.
    * This works by feeding random bits into the data model and
    * decompressing. Premature EOF symbols generated by the
    * model are ignored, and the symbol at that position is resampled.
    * @param rnd random number source
    * @param length maximum number of bytes to generate
    * @param os generated bytes are written here
    * @param ag arithmetic coder to be used for generation */
  public void generate(Random rnd, int length, OutputStream os, Coder ag) 
                                                    throws IOException {
    int sl = 0;
    RandomBitReader rbr = new RandomBitReader(rnd);
    ag.start_decode(rbr,true);  // start decoding, and pad with a 1-bit
    while (sl < length) {
      Integer x = model.decode(ag);
      if (x != eof) {
        os.write((int) x.byteValue());
        model.learn(x);
        sl++;
      }
      // Any generated EOF symbols are ignored.
    }
    model.learn(eof);
    ag.finish_decode();
    os.close();
  }
  
  /** Measures the information content (in bits) of <var>src</var> using
    * the data model's logMass method.
    * <b>Note</b>: this may change the state of the data model.
    * Also note that the "logp" may differ from the actual compression
    * length.
    * @param src byte sequence to be measured */
  public double measureLogMass(Iterable<Byte> src) {
    double info = 0.0;
    for (Byte b : src) {
      info += model.logMass((int) b & 0xFF);
      model.learn((int) b & 0xFF);
      encoded++;
    }
    info += model.logMass(eof);
    return - info / Tools.LN2;
  }
  
  /** Measures the information content (in bits) of <var>src</var> using
    * the data model's {@code encode} method.
    * <b>Note</b>: this changes the state of the data model.
    * @param src byte sequence to be measured
    * @param ac arithmetic coder to be used for compression measurement */
  public long measure(Iterable<Byte> src, Coder ac) {
    BitCounter bc = new BitCounter();
    ac.start_encode(bc);
    for (Byte b : src) {
      model.encode((int) b & 0xFF, ac);
      model.learn((int) b & 0xFF);
      encoded++;
    }
    model.encode(eof, ac);
    try {
      ac.finish_encode();
      bc.close();
    }
    catch (IOException e) {
      // should never happen...
      throw new RuntimeException(e);
    }
    return bc.bitsWritten();
  }

  /** Computes the current predictive distribution.
    * This is attempted first by calling the model's
    * {@code getPredictiveDistribution()} method.  If
    * the model does not implement this method (and
    * throws {@code UnsupportedOperationException} instead),
    * then a brute force copy is produced using the
    * model's {@code mass(Integer)} function.
    * @see AdaptiveCode#getPredictiveDistribution() */
  public Mass<Integer> getPredictiveDistribution() {
    Mass<Integer> predictive = null;
    try {
      predictive = model.getPredictiveDistribution();
    }
    catch (UnsupportedOperationException e) {
      /* This brute-force method will call model.mass(x) for all elements x. */
      predictive = new DiscreteInteger(model,bot,top);
    }
    return predictive;
  }
  
  
  /** Prints the sequence of entropies (in bits) of each
    * conditional predictive distribution.
    * <b>Note</b>: this changes the state of the data model.
    * @see #getPredictiveDistribution()
    * @param src byte sequence
    * @param ps print stream */
  public void entropies(Iterable<Byte> src, PrintStream ps) {
    int pos = 0;
    for (Byte b : src) {
      //Mass<Integer> d = getPredictiveDistribution();
      // compute and print entropy
      double entr = Tools.entropy(model,base);
      ps.println(pos+" \t"+(entr / Tools.LN2));
      // update the model
      model.learn((int) b & 0xFF);
      pos++;
    }
    ps.println(pos+" \t"+(Tools.entropy(model,base) / Tools.LN2));
    model.learn(eof);
    ps.println("# After EOF:");
    ps.println("--- \t"+(Tools.entropy(model,base) / Tools.LN2));
  }
  
  /** Generates a deterministic adversarial (worst case)
    * byte sequence from the data model.
    * This works by picking a least predicted symbol from the
    * predictive distribution every time; when several least
    * predicted symbols exist, the first is chosen deterministically.
    * EOF is excluded.
    * @param length maximum number of bytes to generate
    * @param os generated bytes are written here */
  public void adverse(int length, OutputStream os) throws IOException {
    int sl = 0;
    assert (eof == top); // otherwise, amend the code below!
    while (sl < length) {
      Mass<Integer> mass = getPredictiveDistribution();
      Integer lx = null;
      double lm = Double.POSITIVE_INFINITY;
      for (int k=bot; k<top; k++) {  // EOF=top, so EOF is excluded!
        double m = mass.mass(k);
        if (m < lm) {
          lm = m;
          lx = k;
        }
      }
      os.write(lx.byteValue());
      model.learn(lx);
      sl++;
    }
    os.close();
  }
  
  
  /** Generates a "friendly" deterministic best-case
    * byte sequence from the data model.
    * This works by picking a highest predicted symbol from the
    * predictive distribution every time; when several highest
    * predicted symbols exist, one is chosen deterministically.
    * EOF is excluded.
    * @param length maximum number of bytes to generate
    * @param os generated bytes are written here */
  public void friendly(int length, OutputStream os) throws IOException {
    int sl = 0;
    assert (eof == top); // otherwise, amend the code below!
    while (sl < length) {
      Mass<Integer> mass = getPredictiveDistribution();
      Integer hx = null;
      double hm = Double.NEGATIVE_INFINITY;
      for (int k=bot; k<top; k++) {  // EOF=top, so EOF is excluded!
        double m = mass.mass(k);
        if (m > hm) {
          hm = m;
          hx = k;
        }
      }
      os.write(hx.byteValue());
      model.learn(hx);
      sl++;
    }
    os.close();
  }
  
  /** Pretrains the model with the content of a given file.
    * @param tfnm training filename (or empty string, for <i>stdin</i>) */
  public void train(String tfnm) throws IOException {
    Iterable<Byte> source = IOTools.byteSequenceFromFile(tfnm);
    train(source);
  }
  
  /** Compress input file <var>ifnm</var> to output file <var>ofnm</var>.
    * @param ifnm input filename (or empty string, for <i>stdin</i>)
    * @param ofnm output filename (or empty string, for <i>stdout</i>)
    * @param ac arithmetic coder to be used for compression */
  public void compress(String ifnm, String ofnm, Coder ac) throws IOException {
    Iterable<Byte> source = IOTools.byteSequenceFromFile(ifnm);
    BitWriter target = IOTools.getBitWriter(ofnm);
    compress(source,target,ac);
  }

  /** Decompress input file <var>ifnm</var> to output file <var>ofnm</var>.
    * @param ifnm input filename (or empty string, for <i>stdin</i>)
    * @param ofnm output filename (or empty string, for <i>stdout</i>)
    * @param ad arithmetic coder to be used for decompression */
  public void decompress(String ifnm, String ofnm, Coder ad) throws IOException {
    BitReader source = IOTools.getBitReader(ifnm);
    OutputStream target = IOTools.getOutputStream(ofnm);
    decompress(source,target,ad);
  }
  
  /** Generate a sequence of bytes to a specified output file.
    * @param rnd random source
    * @param n number of symbols to generate
    * @param ofnm output filename (or empty string, for <i>stdout</i>)
    * @param ag arithmetic coder to be used for generation */
  public void generate(Random rnd, int n, String ofnm, Coder ag)
                                                       throws IOException {
    OutputStream target = IOTools.getOutputStream(ofnm);
    generate(rnd,n,target,ag);
    target.close();
  }
  
  /** Generate a sequence of deterministic adverse (worst case) bytes
    * to a specified output file.
    * @param n number of symbols to generate
    * @param ofnm output filename (or empty string, for <i>stdout</i>) */
  public void adverse(int n, String ofnm) throws IOException {
    OutputStream target = IOTools.getOutputStream(ofnm);
    adverse(n,target);
    target.close();
  }
  
  /** Generate a sequence of deterministic friendly (best case) bytes
    * to a specified output file.
    * @param n number of symbols to generate
    * @param ofnm output filename (or empty string, for <i>stdout</i>) */
  public void friendly(int n, String ofnm) throws IOException {
    OutputStream target = IOTools.getOutputStream(ofnm);
    friendly(n,target);
    target.close();
  }
  
  /** Measures the information content (in bits) of <var>src</var> using
    * the data model's {@code encode} method.
    * Calls {@code measure(Iterable<Byte>)}.
    * @param ifnm filename of file to be measured
    * @param ac arithmetic coder to be used for compression measurement
    * @see #measure(Iterable,Coder) */
  public long measure(String ifnm, Coder ac) throws IOException {
    Iterable<Byte> source = IOTools.byteSequenceFromFile(ifnm);
    long bits = measure(source,ac);
    return bits;
  }
  
  /** Measures the information content (in bits) of <var>src</var> using
    * the data model's logMass method.
    * <b>Note</b>: this may change the state of the data model.
    * Also note that the "logp" may differ from the actual compression
    * length.
    * @param ifnm filename of file to be measured
    * @see #measureLogMass(Iterable) */
  public double measureLogMass(String ifnm) throws IOException {
    Iterable<Byte> source = IOTools.byteSequenceFromFile(ifnm);
    double bits = measureLogMass(source);
    return bits;
  }

  /** Returns a String identifier of this compressor instance.
    * Calls {@code mode.toString()}. */
  public String toString() {
    return model.toString();
  }
  
  /** Debugs the compression model by running encoder + decoder
    * next to each other, comparing that they match up.
    * @param src source of input bytes
    * @param modelcopy an exact copy of model, in the same state
    * @param verbose generate verbose output using
    *                DebugEncoder + DebugDecoder
    * @see RegionTracer
    * @see DebugEncoder
    * @see DebugDecoder */
  public void debug(Iterable<Byte> src, AdaptiveCode<Integer> modelcopy,
                                     boolean verbose) throws IOException {
    RegionTracer rt = new RegionTracer();
    Encoder ec = rt;
    Decoder dc = rt;
    if (verbose) {
      ec = new DebugEncoder(rt);
      dc = new DebugDecoder(rt);
    }
    Integer x = null;
    int pos=0;
    try {
      for (Byte b : src) {
        model.encode((int) b & 0xFF, ec);
        model.learn((int) b & 0xFF);
        x = modelcopy.decode(dc);
        modelcopy.learn(x);
        pos++;
      }
      pos = -1;
      model.encode(eof, ec);
      x = modelcopy.decode(dc);
      if (x == eof) {
        System.err.println("Found EOF where expected. Success.");
      } else {
        System.err.println("Found symbol "+x+" but expected EOF ("+eof+"). Failed.");
      }
    }
    catch (RuntimeException e) {
      System.err.println("Exception occurred at sequence position "+pos+":");
      throw e;
    }
  }

  /** Generate raw compression performance plot data,
    * writing to the supplied PrintStream.
    * The data comes in two tab-separated columns: the first
    * column is the offset (in bytes) of the input data, the
    * second column the number of bits written so far.
    * @param src stream of source bytes
    * @param ps PrintStream for plain text plot data
    * @param k thinning parameter. For k &gt; 0: samples every kth point.
    *          For k=0: samples with dynamically decreasing rate.
    * @param ac arithmetic coder to be used */
  public void mkplotdata(Iterable<Byte> src, PrintStream ps, int k, Coder ac) {
    BitCounter bc = new BitCounter();
    ac.start_encode(bc);
    long pos = 0;  // position in input stream
    long prevpos = 0;  // position at previous symbol
    long prevbits = 0; // bitcount at previous symbol
    long lastbits = 0; // bitcount at last written symbol
    long lastpos = -1; // position at last written symbol
    long lastdelta = -1;
    int j = 0;
    for (Byte b : src) {
      if (j == 0) {
        long delta = (bc.bitsWritten() - prevbits);
        /*
        // suppress points which lie on a straight line between two others
        if (delta != lastdelta) {
          if (pos > 0) {
            ps.println(prevpos+" \t"+prevbits);
            lastdelta = delta;
            lastbits = prevbits;
            lastpos = pos;
          } else {
            ps.println(pos+" \t"+bc.bitsWritten());
            lastdelta = delta;
            lastbits = bc.bitsWritten();
            lastpos = pos;
          }
          //ps.println(pos+" \t"+bc.bits());
        }
        */
        ps.println(pos+" \t"+bc.bitsWritten());
        prevpos  = pos;
        prevbits = bc.bitsWritten();
        if (k > 0) {
          j = k-1;     // static thinning
        } else {
          if (pos < 200) { j = 0; } else
          if (pos < 500) { j = 4; } else
          if (pos < 1000) { j = 9; } else
          if (pos < 2000) { j = 19; } else
          if (pos < 5000) { j = 49; } else
          if (pos < 10000) { j = 99; } else
          if (pos < 20000) { j = 199; } else
          if (pos < 50000) { j = 499; } else
          if (pos < 100000) { j = 999; } else
          if (pos < 200000) { j = 1999; } else
          if (pos < 500000) { j = 4999; } else
          if (pos < 1000000) { j = 9999; } else
          if (pos < 2000000) { j = 19999; } else
          if (pos < 5000000) { j = 49999; } else
          if (pos < 10000000) { j = 99999; } else
          if (pos < 20000000) { j = 199999; } else
          if (pos < 50000000) { j = 499999; } else
          if (pos < 100000000) { j = 999999; } else
          {
            int l = (int) Math.floor(Math.log10(pos));
            int s = (int) Math.floor(Math.pow(10.0, l-1));
            j = s - 1;
          }
          // j = (int) (pos/1000); // dynamic thinning
        }
      } else {
        j--;
      }
      model.encode((int) b & 0xFF, ac);
      model.learn((int) b & 0xFF);
      encoded++;
      pos++;
    }
    ps.println(pos+" \t"+bc.bitsWritten());
    ps.println("# after encoding EOF:");
    model.encode(eof, ac);
    ps.println(pos+" \t"+bc.bitsWritten());
    ps.println("# after flushing the arithmetic coder to finish:");
    try {
      ac.finish_encode();
      ps.println(pos+" \t"+bc.bitsWritten());
      bc.close();
    }
    catch (IOException e) {
      // should never happen...
      throw new RuntimeException(e);
    }
  }
  
  /** Generate raw compression performance plot data, writing
    * to plot output file <var>pfnm</var>.
    * @see #mkplotdata(Iterable,PrintStream,int,Coder) */
  public void mkplotdata(Iterable<Byte> src, String pfnm, int k, Coder ac)
                                                        throws IOException {
    PrintStream plotdata = new PrintStream(IOTools.getOutputStream(pfnm));
    mkplotdata(src,plotdata,k,ac);
  }
  
  /** Generate raw compression performance plot data for a given
    * input file, writing to a given plot output file.
    * @param ifnm input filename (or empty string, for <i>stdin</i>)
    * @param pfnm plot output filename (or empty string, for <i>stdout</i>)
    * @param ac arithmetic coder to be used
    * @see #mkplotdata(Iterable,PrintStream,int,Coder) */
  public void mkplotdata(String ifnm, String pfnm, Coder ac) throws IOException {
    Iterable<Byte> src = IOTools.byteSequenceFromFile(ifnm);
    mkplotdata(src,pfnm,0,ac);
  }


  /** Generate symbol by symbol logp plot data,
    * writing to the supplied PrintStream.
    * The data comes in three tab-separated columns: the first
    * column is the offset (in bytes) of the input data, the
    * second column the logp of the symbol at that offset,
    * the third column is the symbol itself (as decimal integer).
    * @param src stream of source bytes
    * @param ps PrintStream for plain text plot data */
  public void plotlogp(Iterable<Byte> src, PrintStream ps) {
    long pos = 0;  // position in input stream
    double logmass = Double.NEGATIVE_INFINITY;
    for (Byte b : src) {
      logmass = model.logMass((int) b & 0xFF) / Tools.LN2;
      ps.println(pos+" \t"+logmass+" \t"+((int) b & 0xFF));
      model.learn((int) b & 0xFF);
      pos++;
    }
    ps.println("# after encoding EOF:");
    logmass = model.logMass(eof) / Tools.LN2;
    ps.println(pos+" \t"+logmass+" \t"+eof);
  }
  
  /** Check that the predictive probability distributions
    * sum to one.
    * The data comes in two tab-separated columns: the first
    * column is the offset (in bytes) of the input data, the
    * second column is the symbol itself, and the third column
    * is the sum of the model's current predictive probabilities.
    * This sum should always equal 1, or be very close to 1.
    * @param src stream of source bytes
    * @param ps PrintStream for diagnostic data */
  public void sumcheck(Iterable<Byte> src, PrintStream ps) {
    long pos = 0;  // position in input stream
    for (Byte b : src) {
      Mass<Integer> pred = getPredictiveDistribution();
      double sum = 0.0;
      for (int k=bot; k<=top; k++) { sum += pred.mass(k); }
      ps.println(pos+" \t"+((int) b & 0xFF)+" \t"+sum);
      model.learn((int) b & 0xFF);
      pos++;
    }
    ps.println("# after encoding EOF:");
    Mass<Integer> pred = getPredictiveDistribution();
    double sum = 0.0;
    for (int k=bot; k<=top; k++) { sum += pred.mass(k); }
    ps.println(pos+" \t"+eof+" \t"+sum);
  }
  
  /** Generate symbol by symbol debug information,
    * writing to the supplied PrintStream.
    * The data comes in two tab-separated columns: the first
    * column is the offset (in bytes) of the input data, the
    * second column contains the model specific debug information.
    * @param src stream of source bytes
    * @param ps PrintStream for plain text plot data */
  public void plotstate(Iterable<Byte> src, PrintStream ps) {
    long pos = 0;  // position in input stream
    java.lang.reflect.Method method = null;
    try {
      try {
        method = model.getClass().getMethod("getStateInfo");
      } catch (SecurityException e) {
      } catch (NoSuchMethodException e) {
      }
      for (Byte b : src) {
        ps.println(pos+" \t"+(b & 0xFF)+" \t"+method.invoke(model));
        model.learn((int) b & 0xFF);
        pos++;
      }
      ps.println("# before learning EOF:");
      ps.println(pos+" \t"+eof+" \t"+method.invoke(model));
      //model.learn(eof);
      //ps.println("# after learning EOF:");
      ps.println(pos+" \t--- \t"+method.invoke(model));
    }
    catch (IllegalAccessException e) {
      throw new RuntimeException(e);
    }
    catch (java.lang.reflect.InvocationTargetException e) {
      throw new RuntimeException(e);
    }
  }
  
  /** Generate logp plot data, writing to output file <var>pfnm</var>.
    * @see #plotlogp(Iterable,PrintStream) */
  public void plotlogp(Iterable<Byte> src, String pfnm)
                                                       throws IOException {
    PrintStream plotdata = new PrintStream(IOTools.getOutputStream(pfnm));
    plotlogp(src,plotdata);
  }
  
  /** Generate logp plot data for input file <var>ifnm</var>,
    * writing to output file <var>pfnm</var>.
    * @see #plotlogp(Iterable,PrintStream) */
  public void plotlogp(String ifnm, String pfnm)
                                                       throws IOException {
    Iterable<Byte> src = IOTools.byteSequenceFromFile(ifnm);
    plotlogp(src,pfnm);
  }
  

}
